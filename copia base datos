USE proyectoMonedas;

 
SET FOREIGN_KEY_CHECKS = 0; 

 await connection.query(`

      CREATE TABLE users (
        
          id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
          createDate DATETIME NOT NULL DEFAULT NOW(),
          name VARCHAR(50) NOT NULL,
          lastname VARCHAR(50) NOT NULL,
          dni VARCHAR(10) NOT NULL ,
          adress VARCHAR(50) NOT NULL,
          zip_code VARCHAR(5)NOT NULL,
          city VARCHAR(50)NOT NULL,
          telephone VARCHAR(15)NOT NULL,
          email VARCHAR(50) UNIQUE NOT NULL,
          bank_account VARCHAR(20) NOT NULL UNIQUE ,
          user_name VARCHAR(20) NOT NULL UNIQUE,
          password VARCHAR(128)NOT NULL,
          lastUpdate DATETIME NOT NULL
              );
    `);

    await connection.query(`
      CREATE TABLE moneys (
          id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
          createDate DATETIME NOT NULL DEFAULT NOW(),
          price FLOAT DEFAULT 0,
          locate VARCHAR(50) NOT NULL,
          money_type ENUM('Dolares','Libras','Euros') DEFAULT "Euros",
          money_country ENUM('ES','UK','EEUU') DEFAULT "ES",
          rating VARCHAR(20),
          coments VARCHAR (100),
          seller VARCHAR (50) NOT NULL UNIQUE,
          id_user INT UNSIGNED,
          FOREIGN KEY (id_user) REFERENCES users(id) ON DELETE CASCADE,
          lastUpdate DATETIME NOT NULL
        
      );
    `);

    await connection.query(`
      CREATE TABLE bookings (
          id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
          createDate DATETIME NOT NULL DEFAULT NOW(),
          selected_money VARCHAR(50),
          selected_quantity DECIMAL(4,2),
          booking_date DATE,
          delivery_date DATE,
          order_number VARCHAR(10),
          delivery_adress VARCHAR(50),
          name VARCHAR(50) NOT NULL,
          surname VARCHAR(50)NOT NULL,
          email VARCHAR(50) NOT NULL UNIQUE,
          telephone VARCHAR(50) NOT NULL UNIQUE ,
          payment FLOAT DEFAULT 0,
          pament_date DATE,
          total_payment FLOAT DEFAULT 0,
          credit_card_type ENUM('visa','mastercard') DEFAULT 'visa' NOT NULL,
          account_number VARCHAR(20) NOT NULL UNIQUE,
          expiration_date DATE NOT NULL,
          cvc VARCHAR(3) NOT NULL,
          id_user INT UNSIGNED,
          FOREIGN KEY (id_user) REFERENCES users(id) ON DELETE CASCADE,
          id_money INT UNSIGNED,
          FOREIGN KEY (id_money) REFERENCES moneys (id) ON DELETE CASCADE,
           lastUpdate DATETIME NOT NULL
        
      );

SET FOREIGN_KEY_CHECKS = 1; 



 const { idUser } = req.auth.id;
    console.log(req.params);

    const { idEntry} = req.params;

    console.log(idUser, idEntry);








 //NO NECESITO ESTO,estaba en new entry
    /* // Comprobar que no no existe una entrada con el mismo place
    const [existingEntry] = await connection.query(
      `
      SELECT id 
      FROM proyectoMonedas
      WHERE money_type=?,selected_quantity=?,price=?,locate=?
    `,
      [money_type, selected_quantity, price, locate]
    );

    if (existingEntry.length > 0) {
      const error = new Error(
        "Ya existe una entrada en la base de datos con esos campos"
      );
      error.httpStatus = 409;
      throw error;
    } */










    const { getConnection } = require("../../db");

const { newEntrySchema } = require("../../validators/diaryValidators");
const {
  processAndSaveImage,
  deleteUpload,
  generateError,
} = require("../../helpers");
const { throttle } = require("lodash");

//Procesar la imagen si existe
let saveImageFileName;

/*  //Procesar la imagen si esta en el body
if (req.files && req.files.image) {
  try {
    //Procesar y gaurdar imagen

    saveImageFileName = await processAndSaveImage(reqfiles.image);
  } catch (error) {
    throw generateError(
      "No se pudo procesar la imagen. INtentalo de nuevo",
      400
    );
  } 
} */

const images = [];

if (req.files && Object.keys(req.files).length > 0) {
  for (const [imageName, imageData] of Object.entries(req.files).slice) 0, 2;
  try {
    // showDebug(imageName);

    const processedImage = await processAndSaveImage(imageData);

    images.push(processedImage);

    await connection.query(
      ` 
        INSERT INTO moneys_images(image, money_id)
        VALUES (?,?)
        `,
      [processedImage, result.insertId]
    );
  } catch (error) {
    throw generateError(
      "no se pudo procesar la imagen.Intentalo de nuevo",
      400
    );
  }
}

async function newMoney(req, res, next) {
  let connection;
  try {
    connection = await getConnection();

    await newEntrySchema.validateAsync(req.body);

    // Sacar de req.body los datos que necesitio
    const {
      price,
      locate,
      money_type,
      money_country,
      coments,
      seller,
      images,
    } = req.body;

    // Ejecutar la query
    const [result] = await connection.query(
      `
      INSERT INTO moneys(price,locate,money_type,money_country,coments,seller,id_user_seller,lastUpdate)
      VALUES(?,?,ENUM('Dolares','Libras','Euros'),NUM('ES','UK','EEUU'),?,?,?,NOW())
      `,
      [
        price,
        locate,
        money_type,
        money_country,
        coments,
        seller,
        images,
        req.auth.id,
      ]
    );

    // Si hay imágenes, procesar cada imagen y meterla en la tabla diary_images
    // Con la referencia a la entrada que acabo de meter

    // Devolver el resultado

    res.send({
      status: "ok",
      data: {
        id: result.insertId,
        price,
        locate,
        money_type,
        money_country,
        coments,
        seller,
        images,
      },
    });
  } catch (error) {
    next(error);
  } finally {
    if (connection) connection.release();
  }
}

module.exports = newMoney;


















nuevo articulo

const { getConnection } = require("../../db");
const { processAndSaveImage } = require("../../helpers");

async function newBooking(req, res, next) {
  let connection;
  try {
    connection = await getConnection();

    // Sacar de req.body los datos que necesitio
    const { id_money, selected_quantity } = req.body;

    // Comprobar que están todos los datos necesarios
    if (!id_money || !selected_quantity) {
      const error = new Error("Faltan datos obligatorios en la petición.");
      error.httpStatus = 400;
      throw error;
    }

    let savedImageFileName;

    // Procesar la imagen si está en el body
    if (req.files && req.files.image) {
      try {
        // Procesar y guardar imagen
        savedImageFileName = await processAndSaveImage(req.files.image);
      } catch (error) {
        const imageError = new Error(
          "No se pudo procesar la imagen. Inténtalo de nuevo"
        );
        imageError.httpStatus = 400;
        throw imageError;
      }
    }

    // Ejecutar la query
    const [result] = await connection.query(
      `
      INSERT INTO proyectoMoneda(money_type,selected_quantity,lastUpdate, user_id)
      VALUES(?,?,?,NOW(), ?)
      `,
      [id_money, selected_quantity, req.auth.id]
    );

    // Devolver el resultado

    res.send({
      status: "ok",
      data: {
        id: result.insertId,
        id_money,
        selected_quantity,

        image: savedImageFileName,
      },
    });
  } catch (error) {
    next(error);
  } finally {
    if (connection) connection.release();
  }
}

module.exports = newBooking;














querys 

//esta es la que estabas haciendo:

async function listmoneys(req, res, next) {
  let connection;

  try {
    connection = await getConnection();

    const { search, order, direction } = req.query;

    const orderDirection =
      (direction && direction.toLowerCase()) === "desc" ? "DESC" : "ASC";

    let orderBy;
    switch (order) {
      case "type":
        orderBy = "type";
        break;
      case "price":
        orderBy = "price";
        break;
      case "locate":
        orderBy = "locate";
        break;
    }

    let queryResults;
    console.log("hasta aqui");
    if (search) {
      queryResults = await connection.query(
        `
      SELECT 
moneys.id
, moneys.money_type, moneys.price, moneys.locate, moneys.id_user_seller
      FROM moneys
      WHERE price LIKE ? 
      ORDER BY ${orderBy} ${orderDirection}
      `,
        [`%${search}%`, `${search}%`]
      );
    } else {
      queryResults = await connection.query(
        `
        SELECT 
moneys.id
, moneys.money_type, moneys.price, moneys.locate, moneys.id_user_seller
        FROM moneys
        ORDER BY ${orderBy} ${orderDirection}
        `
      );
    }

    const [result] = queryResults;

    res.send({
      status: "ok",
      data: result,
    });
  } catch (error) {
    next(error);
  } finally {
    if (connection) connection.release();
  }
}

module.exports = listmoneys;

________________________________________________________________________




const { getConnection } = require("../../db");

async function listProducts(req, res, next) {
  let connection;

  try {
    connection = await getConnection();

    const { search, order, direction } = req.query;

    const orderDirection =
      (direction && direction.toLowerCase()) === "desc" ? "DESC" : "ASC";

    let orderBy;
    switch (order) {
      case "council":
        orderBy = "council";
        break;
      case "price":
        orderBy = "price";
        break;
      case "category":
        orderBy = "category";
        break;
    }

    let queryResults;
    if (search) {
      queryResults = await connection.query(
        `
      SELECT 
bbdd.id
, bbdd.council, bbdd.price, bbdd.category, bbdd.user_id,
      FROM bbdd
      WHERE council LIKE ? 
      ORDER BY ${orderBy} ${orderDirection}
      `,
        [`%${search}%`, `${search}%`]
      );
    } else {
      queryResults = await connection.query(
        `
        SELECT 
bbdd.id
, bbdd.council, bbdd.price, bbdd.category, bbdd.user_id,
        FROM bbdd
        ORDER BY ${orderBy} ${orderDirection}
        `
      );
    }

    const [result] = queryResults;

    res.send({
      status: "ok",
      data: result,
    });
  } catch (error) {
    next(error);
  } finally {
    if (connection) connection.release();
  }
}

module.exports = listProducts;

___________________________________________________

let connection;
const category = req.query.category;
const price1 = req.query.price1;
const price2 = req.query.price2;
const brand = req.query.brand;
const locality = req.query.locality;

let sql = 'SELECT * FROM articles';
let count = 0;

if ((category) || (price1) || (price2) || (brand) || (locality)) {
sql += ' WHERE ';
}

if (category) {
sql += 'category = ${category}';
count++;
}

if ($brand) {
if (count > 0)
sql += " AND ";
sql += ' brand = ${brand}'
count++;
}

// TODO To be continued . . .

sql += 'price BETWEEN ${price1} AND ${price2}';